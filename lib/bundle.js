/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/entry.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/beerman.js":
/*!************************!*\
  !*** ./lib/beerman.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const MovingObject = __webpack_require__(/*! ./moving_object */ \"./lib/moving_object.js\");\n\nconst DEFAULTS = {\n  dir: [1, 0],\n  vel: 4,\n  radius: 15,\n  gridSize: 40,\n  wallSize: 4\n};\n\nclass Beerman extends MovingObject {\n  constructor(options) {\n    options.dir = DEFAULTS.dir;\n    options.vel = DEFAULTS.vel;\n    options.radius = DEFAULTS.radius;\n    super(options);\n    this.numBeers = 0;\n    this.openMouth = true;\n    this.poweredUp = false;\n    this.numSteps = 0;\n    this.dying = false;\n  }\n\n  render(ctx) {\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    const centerPos = [this.pos[0] + DEFAULTS.gridSize / 2 + DEFAULTS.wallSize / 2, this.pos[1] + DEFAULTS.gridSize / 2 + DEFAULTS.wallSize / 2];\n    if (this.openMouth) {\n      if (this.dir[0] === -1 && this.dir[1] === 0) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 7 / 9, 2 * Math.PI - Math.PI * 11 / 9);\n      } else if (this.dir[0] === 0 && this.dir[1] === -1) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 2 / 9, 2 * Math.PI - Math.PI * 7 / 9);\n      } else if (this.dir[0] === 1 && this.dir[1] === 0) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 16 / 9, 2 * Math.PI - Math.PI * 2 / 9);\n      } else if (this.dir[0] === 0 && this.dir[1] === 1) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 11 / 9, 2 * Math.PI - Math.PI * 16 / 9);\n      }\n    } else {\n      if (this.dir[0] === -1 && this.dir[1] === 0) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 17 / 18, 2 * Math.PI - Math.PI * 19 / 18);\n      } else if (this.dir[0] === 0 && this.dir[1] === -1) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 8 / 18, 2 * Math.PI - Math.PI * 10 / 18);\n      } else if (this.dir[0] === 1 && this.dir[1] === 0) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 35 / 18, 2 * Math.PI - Math.PI * 1 / 18);\n      } else if (this.dir[0] === 0 && this.dir[1] === 1) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 26 / 18, 2 * Math.PI - Math.PI * 28 / 18);\n      }\n    }\n    ctx.lineTo(centerPos[0], centerPos[1]);\n    ctx.fill();\n    this.numSteps += 1;\n    if (this.numSteps >= 10) {\n      this.openMouth = !(this.openMouth);\n      this.numSteps = 0;\n    }\n  }\n\n  die(ctx) {\n    this.dying = true;\n    ctx.fillStyle = this.color;\n    const centerPos = [this.pos[0] + DEFAULTS.gridSize / 2 + DEFAULTS.wallSize / 2, this.pos[1] + DEFAULTS.gridSize / 2 + DEFAULTS.wallSize / 2];\n\n    setTimeout(() => {\n      this.drawState(ctx, centerPos, [Math.PI / 4, Math.PI * 7 / 4]);\n      setTimeout(() => {\n        this.drawState(ctx, centerPos, [Math.PI / 2, Math.PI * 3 / 2]);\n        setTimeout(() => {\n          this.drawState(ctx, centerPos, [Math.PI * 3 / 4, Math.PI * 5 / 4]);\n          setTimeout(() => {\n            this.drawState(ctx, centerPos, [Math.PI, Math.PI]);\n          }, 300);\n        }, 300);\n      }, 300);\n    }, 300);\n  }\n\n  drawState(ctx, centerPos, angles) {\n    this.board.render(ctx);\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    ctx.arc(centerPos[0], centerPos[1], this.radius, angles[0], angles[1]);\n    ctx.lineTo(centerPos[0], centerPos[1]);\n    ctx.fill();\n  }\n}\n\nmodule.exports = Beerman;\n\n//# sourceURL=webpack:///./lib/beerman.js?");

/***/ }),

/***/ "./lib/board.js":
/*!**********************!*\
  !*** ./lib/board.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Board {\n  constructor(options) {\n    this.pos = options.pos;\n    this.width = options.width;\n    this.height = options.height;\n    this.numRows = 16;\n    this.numCols = this.numRows;\n    this.walls = {\n      \"LEFT\": [],\n      \"TOP\": [],\n      \"RIGHT\": [],\n      \"BOTTOM\": []\n    };\n    this.drinkLocations = JSON.parse(JSON.stringify((DRINK_LOCATIONS)));\n  }\n\n  render(ctx) {\n    this.resetWalls();\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(this.pos[0], this.pos[1], this.width, this.height);\n    for (let row = 0; row < this.numRows; row++) {\n      for (let col = 0; col < this.numCols; col++) {\n        if (this.drinkLocations[row][col] === 1) {\n          this.drawBeer(ctx, row, col);\n        }\n        if (this.drinkLocations[row][col] === 2) {\n          this.drawCoffee(ctx, row, col);\n        }\n        switch (EDGES[row][col]) {\n          case LEFT:\n            this.drawLeftEdge(ctx, row, col);\n            break;\n          case TOP:\n            this.drawTopEdge(ctx, row, col);\n            break;\n          case RIGHT:\n            this.drawRightEdge(ctx, row, col);\n            break;\n          case BOTTOM:\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case LEFT_TOP:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawTopEdge(ctx, row, col);\n            break;\n          case LEFT_RIGHT:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawRightEdge(ctx, row, col);\n            break;\n          case LEFT_BOTTOM:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case TOP_RIGHT:\n            this.drawTopEdge(ctx, row, col);\n            this.drawRightEdge(ctx, row, col);\n            break;\n          case TOP_BOTTOM:\n            this.drawTopEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case RIGHT_BOTTOM:\n            this.drawRightEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case LEFT_TOP_RIGHT:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawTopEdge(ctx, row, col);\n            this.drawRightEdge(ctx, row, col);\n            break;\n          case TOP_RIGHT_BOTTOM:\n            this.drawTopEdge(ctx, row, col);\n            this.drawRightEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case LEFT_BOTTOM_RIGHT:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            this.drawRightEdge(ctx, row, col);\n            break;\n          case LEFT_TOP_BOTTOM:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawTopEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case FOUR_SIDES:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawTopEdge(ctx, row, col);\n            this.drawRightEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case EMPTY:\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }\n\n  drawBeer(ctx, row, col) {\n    ctx.font = \"16px Arial\";\n    ctx.fillText(String.fromCodePoint(0x1F37A), col * SIZES.gridSize + 12, row * SIZES.gridSize + 30);\n  }\n\n  drawCoffee(ctx, row, col) {\n    ctx.font = \"20px Arial\";\n    ctx.fillText(String.fromCodePoint(0x2615), col * SIZES.gridSize + 11, row * SIZES.gridSize + 30);\n  }\n\n  drawLeftEdge(ctx, row, col) {\n    ctx.fillStyle = \"blue\";\n    const pos = [col * SIZES.gridSize, row * SIZES.gridSize];\n    ctx.fillRect(\n      pos[0],\n      pos[1],\n      SIZES.wall,\n      SIZES.gridSize + SIZES.wall\n    );\n    this.storeWalls(pos, \"LEFT\");\n  }\n\n\n  drawTopEdge(ctx, row, col) {\n    ctx.fillStyle = \"blue\";\n    const pos = [col * SIZES.gridSize, row * SIZES.gridSize];\n    ctx.fillRect(\n      pos[0],\n      pos[1],\n      SIZES.gridSize,\n      SIZES.wall\n    );\n    this.storeWalls(pos, \"TOP\");\n  }\n\n  drawRightEdge(ctx, row, col) {\n    ctx.fillStyle = \"blue\";\n    const pos = [col * SIZES.gridSize, row * SIZES.gridSize];\n    ctx.fillRect(\n      pos[0] + SIZES.gridSize,\n      pos[1],\n      SIZES.wall,\n      SIZES.gridSize + SIZES.wall\n    );\n    this.storeWalls(pos, \"RIGHT\");\n  }\n\n  drawBottomEdge(ctx, row, col) {\n    ctx.fillStyle = \"blue\";\n    const pos = [col * SIZES.gridSize, row * SIZES.gridSize];\n    ctx.fillRect(\n      pos[0],\n      pos[1] + SIZES.gridSize,\n      SIZES.gridSize,\n      SIZES.wall\n    );\n    this.storeWalls(pos, \"BOTTOM\");\n  }\n\n  isEmpty() {\n    for (let row = 0; row < DRINK_LOCATIONS.length; row++) {\n      for (let col = 0; col < DRINK_LOCATIONS.length; col++) {\n        if (this.drinkLocations[row][col] > 0) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  removeDrink(row, col) {\n    this.drinkLocations[row][col] = 0;\n  }\n\n  resetWalls() {\n    this.walls = {\n      \"LEFT\": [],\n      \"TOP\": [],\n      \"RIGHT\": [],\n      \"BOTTOM\": []\n    };\n  }\n\n  storeWalls(pos, dir) {\n    this.walls[dir].push(pos);\n  }\n\n  resetBoard() {\n    this.drinkLocations = JSON.parse(JSON.stringify((DRINK_LOCATIONS)));\n  }\n}\n\nconst SIZES = {\n  wall: 4,\n  gridSize: 40\n};\n\nconst LEFT = \"LEFT\";\nconst TOP = \"TOP\";\nconst RIGHT = \"RIGHT\";\nconst BOTTOM = \"BOTTOM\";\nconst LEFT_TOP = \"LEFT_TOP\";\nconst LEFT_RIGHT = \"LEFT_RIGHT\";\nconst LEFT_BOTTOM = \"LEFT_BOTTOM\";\nconst TOP_RIGHT = \"TOP_RIGHT\";\nconst TOP_BOTTOM = \"TOP_BOTTOM\";\nconst RIGHT_BOTTOM = \"RIGHT_BOTTOM\";\nconst LEFT_TOP_RIGHT = \"LEFT_TOP_RIGHT\";\nconst TOP_RIGHT_BOTTOM = \"TOP_RIGHT_BOTTOM\";\nconst LEFT_BOTTOM_RIGHT = \"LEFT_BOTTOM_RIGHT\";\nconst LEFT_TOP_BOTTOM = \"LEFT_TOP_BOTTOM\";\nconst FOUR_SIDES = \"FOUR_SIDES\";\nconst EMPTY = \"EMPTY\";\n\nconst EDGES = [\n  [LEFT_TOP, TOP_BOTTOM, TOP_BOTTOM, TOP, TOP_BOTTOM, TOP_BOTTOM, TOP_BOTTOM,\n    TOP_RIGHT, LEFT_TOP, TOP_BOTTOM, TOP_BOTTOM, TOP_BOTTOM, TOP, TOP_BOTTOM, TOP_BOTTOM, TOP_RIGHT],\n  [LEFT_RIGHT, BOTTOM, RIGHT_BOTTOM, RIGHT, BOTTOM, BOTTOM, RIGHT_BOTTOM, RIGHT,\n    RIGHT, BOTTOM, BOTTOM, RIGHT_BOTTOM, EMPTY, LEFT_BOTTOM, RIGHT_BOTTOM, RIGHT],\n  [LEFT, BOTTOM, BOTTOM, EMPTY, EMPTY, EMPTY, BOTTOM, BOTTOM,\n    BOTTOM, BOTTOM, EMPTY, EMPTY, EMPTY, BOTTOM, BOTTOM, RIGHT],\n  [LEFT, LEFT_BOTTOM, RIGHT_BOTTOM, RIGHT, LEFT_TOP, LEFT, LEFT_TOP_BOTTOM, TOP_BOTTOM,\n    TOP_BOTTOM, TOP_RIGHT_BOTTOM, EMPTY, LEFT_TOP_RIGHT, EMPTY, LEFT_TOP_BOTTOM, TOP_RIGHT_BOTTOM, RIGHT],\n  [LEFT_BOTTOM, BOTTOM, BOTTOM, RIGHT, EMPTY, LEFT_BOTTOM, BOTTOM, RIGHT, EMPTY, BOTTOM,\n    RIGHT_BOTTOM, RIGHT, EMPTY, BOTTOM, BOTTOM, RIGHT_BOTTOM],\n  [EMPTY, EMPTY, EMPTY, LEFT, LEFT, BOTTOM, RIGHT_BOTTOM, EMPTY,\n    LEFT, LEFT_BOTTOM, BOTTOM, RIGHT, RIGHT, EMPTY, EMPTY, EMPTY],\n  [EMPTY, EMPTY, EMPTY, LEFT, LEFT, LEFT, EMPTY, EMPTY,\n    EMPTY, EMPTY, RIGHT, RIGHT, RIGHT, EMPTY, EMPTY, EMPTY],\n  [EMPTY, EMPTY, RIGHT, EMPTY, LEFT_BOTTOM, LEFT, LEFT_TOP, EMPTY, EMPTY,\n    TOP_RIGHT, EMPTY, LEFT_RIGHT, RIGHT, EMPTY, EMPTY, EMPTY],\n  [TOP, TOP, TOP, EMPTY, EMPTY, EMPTY, LEFT_BOTTOM, BOTTOM,\n    BOTTOM, RIGHT_BOTTOM, EMPTY, TOP_BOTTOM, EMPTY, TOP, TOP, TOP],\n  [TOP, TOP, TOP_RIGHT, RIGHT, TOP_RIGHT, EMPTY, BOTTOM, BOTTOM, BOTTOM,\n    BOTTOM, RIGHT, RIGHT, EMPTY, LEFT_TOP, TOP, TOP],\n  [BOTTOM, BOTTOM, RIGHT_BOTTOM, RIGHT, RIGHT_BOTTOM, EMPTY, LEFT_BOTTOM,\n    BOTTOM, BOTTOM, RIGHT_BOTTOM, RIGHT, RIGHT_BOTTOM, RIGHT, BOTTOM, BOTTOM, BOTTOM],\n  [LEFT, BOTTOM, BOTTOM, EMPTY, BOTTOM, BOTTOM, BOTTOM, RIGHT, EMPTY, BOTTOM,\n    BOTTOM, BOTTOM, EMPTY, BOTTOM, BOTTOM, RIGHT],\n  [LEFT, LEFT_BOTTOM, RIGHT, EMPTY, LEFT_BOTTOM, BOTTOM, RIGHT_BOTTOM, RIGHT,\n    EMPTY, LEFT_BOTTOM, BOTTOM, RIGHT_BOTTOM, EMPTY, LEFT, RIGHT_BOTTOM, RIGHT],\n  [LEFT, RIGHT, RIGHT_BOTTOM, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,\n    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, LEFT_BOTTOM, LEFT, RIGHT],\n  [LEFT_TOP, BOTTOM, BOTTOM, BOTTOM, LEFT_BOTTOM, TOP_BOTTOM, TOP_BOTTOM, TOP_RIGHT,\n    TOP, TOP_BOTTOM, TOP_BOTTOM, RIGHT_BOTTOM, BOTTOM, BOTTOM, BOTTOM, TOP_RIGHT],\n  [LEFT_BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM,\n    BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, RIGHT_BOTTOM]\n];\n\nconst DRINK_LOCATIONS = [\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [2, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 2],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1],\n  [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1],\n  [2, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 2],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n];\n\n// const TILES = [\n//   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n//   [1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1],\n//   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n//   [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1],\n//   [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],\n//   [0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0],\n//   [0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0],\n//   [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\n//   [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1],\n//   [0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0],\n//   [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\n//   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n//   [1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1],\n//   [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],\n//   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n//   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n// ];\n\n\nmodule.exports = Board;\n\n//# sourceURL=webpack:///./lib/board.js?");

/***/ }),

/***/ "./lib/entry.js":
/*!**********************!*\
  !*** ./lib/entry.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const GameView = __webpack_require__(/*! ./game_view */ \"./lib/game_view.js\");\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n  canvasEl.height = 645;\n  canvasEl.width = 800;\n  const ctx = canvasEl.getContext(\"2d\");\n  const view = new GameView(ctx);\n});\n\n\n//# sourceURL=webpack:///./lib/entry.js?");

/***/ }),

/***/ "./lib/game.js":
/*!*********************!*\
  !*** ./lib/game.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Beerman = __webpack_require__(/*! ./beerman */ \"./lib/beerman.js\");\nconst Ghost = __webpack_require__(/*! ./ghost */ \"./lib/ghost.js\");\nconst DEFAULTS = {\n  bmanVel: 4,\n  ghostVel: 2,\n  gridSize: 40,\n  wallSize: 4,\n  lives: 2,\n  bmanDir: [1, 0],\n  ghostDir: [-1, 0]\n};\n\nclass Game {\n\n  constructor(ctx, board) {\n    this.defaultCharPos = [[320, 360], [240, 240], [280, 240], [320, 240], [360, 240]];\n    const beerman = new Beerman({ pos: this.defaultCharPos[0], color: \"#FFFF00\", board });\n    const blinky = new Ghost({ pos: this.defaultCharPos[1], color: \"#FF0000\", board, beerman, name: \"blinky\" });\n    const pinky = new Ghost({ pos: this.defaultCharPos[2], color: \"#FF69B4\", board, beerman, name: \"pinky\" });\n    const inky = new Ghost({ pos: this.defaultCharPos[3], color: \"#00FFFF\", board, beerman, name: \"inky\", blinky: blinky });\n    const clyde = new Ghost({ pos: this.defaultCharPos[4], color: \"#FFA500\", board, beerman, name: \"clyde\" });\n    this.ctx = ctx;\n    this.board = board;\n    this.chars = [beerman, blinky, pinky, inky, clyde];\n    this.gameOver = false;\n    this.won = false;\n    this.score = 0;\n    this.powerTimer = 0;\n    this.lives = DEFAULTS.lives;\n    this.lostLife = false;\n    this.render(ctx);\n  }\n\n  render(ctx) {\n    this.ctx.textAlign = \"left\";\n    this.board.render(ctx);\n    const beermanPos = this.chars[0].pos;\n    this.chars.forEach((char, idx) => {\n      char.render(ctx);\n      if (idx >= 1 && this.checkCollision(char.pos, beermanPos)) {\n        if (this.chars[0].poweredUp) {\n          char.die(ctx);\n          this.score += 1000;\n        } else {\n          this.lives -= 1;\n          this.chars[0].die(ctx);\n          this.lostLife = true;\n        }\n      }\n    });\n    this.won = this.board.isEmpty();\n    this.gameOver = (this.lives === 0);\n  }\n\n  checkCollision(pos1, pos2) {\n    return ((Math.abs(pos1[0] - pos2[0]) <= 2) && Math.abs(pos1[1] - pos2[1]) <= 2);\n  }\n\n  moveChars(walls) {\n    this.chars.forEach((char, idx) => {\n      if (idx === 0) {\n        this.bmanDrink();\n      }\n      char.move(walls);\n    });\n  }\n\n  bmanDrink() {\n    const bman = this.chars[0];\n    if (bman.pos[0] % DEFAULTS.gridSize === 0 && bman.pos[0] % DEFAULTS.gridSize === 0) {\n      const row = Math.floor(bman.pos[1] / DEFAULTS.gridSize);\n      const col = Math.floor(bman.pos[0] / DEFAULTS.gridSize);\n      if (this.board.drinkLocations[row][col] === 1) {\n        this.board.removeDrink(Math.floor(bman.pos[1] / DEFAULTS.gridSize), Math.floor(bman.pos[0] / DEFAULTS.gridSize));\n        bman.numBeers += bman.poweredUp ? 0.5 : 1;\n        bman.vel = DEFAULTS.bmanVel * Math.pow((1 / 2), (Math.floor(bman.numBeers / 20)));\n        if (bman.vel < DEFAULTS.bmanVel && bman.color !== \"green\") {\n          bman.color = \"green\";\n        }\n        this.score += 100;\n      } else if (this.board.drinkLocations[row][col] === 2) {\n        this.board.removeDrink(Math.floor(bman.pos[1] / DEFAULTS.gridSize), Math.floor(bman.pos[0] / DEFAULTS.gridSize));\n        bman.pos = [Math.floor(bman.pos[0] / DEFAULTS.wallSize) * DEFAULTS.wallSize, Math.floor(bman.pos[1] / DEFAULTS.wallSize) * DEFAULTS.wallSize];\n        bman.numBeers = 0;\n        bman.vel = DEFAULTS.bmanVel;\n        bman.color = \"yellow\";\n        bman.poweredUp = true;\n        window.clearTimeout(this.powerTimer);\n        this.powerTimer = setTimeout(() => {\n          bman.poweredUp = false;\n        }, 7000);\n        this.score += 500;\n      }\n    }\n  }\n\n  resetChars() {\n    this.chars[0].openMouth = true;\n    this.chars[0].dying = false;\n    this.chars.forEach((char, idx) => {\n      char.pos = this.defaultCharPos[idx];\n      if (idx === 0) {\n        char.dir = DEFAULTS.bmanDir;\n        char.vel = DEFAULTS.bmanVel;\n        char.numBeers = 0;\n        char.color = \"yellow\";\n      } else {\n        char.dir = DEFAULTS.ghostDir;\n        char.vel = DEFAULTS.ghostVel;\n        char.isDead = false;\n      }\n    });\n  }\n\n  resetGame() {\n    this.resetChars();\n    this.score = 0;\n    this.lives = DEFAULTS.lives;\n    this.gameOver = false;\n    this.won = false;\n  }\n\n  // initializeAudio() {\n  //   this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  //   const bufferLoader = new BufferLoader(\n  //     this.audioContext,\n  //     [\n  //       '../audio/pacman_beginning.wav',\n  //       '../audio/pacman_chomp.wav',\n  //       '../audio/pacman_eatfruit.wav',\n  //       '../audio/pacman_eatghost.wav',\n  //       '../audio/pacman_death.wav'\n  //     ],\n  //     this.finishedLoading\n  //   );\n  //   bufferLoader.load();\n  // }\n}\n// finishedLoading(bufferList) {\n//   bufferList.forEach(buffer => {\n//     let source = this.audioContext.createBufferSource();\n//     source.buffer = buffer;\n//     source.connect(this.audioContext.destination);\n//     this.sources.push(source);\n//   });\n// }\n\n// class BufferLoader {\n//   constructor(context, urlList, callback) {\n//     this.context = context;\n//     this.urlList = urlList;\n//     this.onload = callback;\n//     this.bufferList = new Array();\n//     this.loadCount = 0;\n//   }\n\n//   loadBuffer(url, index) {\n//     // Load buffer asynchronously\n//     const request = new XMLHttpRequest();\n//     request.open(\"GET\", url, true);\n//     request.responseType = \"arraybuffer\";\n\n//     const loader = this;\n\n//     request.onload = () => {\n//       // Asynchronously decode the audio file data in request.response\n//       loader.context.decodeAudioData(\n//         request.response,\n//         (buffer) => {\n//           if (!buffer) {\n//             alert('error decoding file data: ' + url);\n//             return;\n//           }\n//           loader.bufferList[index] = buffer;\n//           if (++loader.loadCount === loader.urlList.length)\n//             loader.onload(loader.bufferList);\n//         },\n//         (error) => {\n//           console.error('decodeAudioData error', error);\n//         }\n//       );\n//     };\n\n//     request.onerror = () => alert('BufferLoader: XHR error');\n//     request.send();\n//   }\n\n//   load() {\n//     for (let i = 0; i < this.urlList.length; i++) {\n//       this.loadBuffer(this.urlList[i], i);\n//     }\n//   }\n\nmodule.exports = Game;\n\n//# sourceURL=webpack:///./lib/game.js?");

/***/ }),

/***/ "./lib/game_view.js":
/*!**************************!*\
  !*** ./lib/game_view.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Board = __webpack_require__(/*! ./board */ \"./lib/board.js\");\nconst Game = __webpack_require__(/*! ./game */ \"./lib/game.js\");\n\nconst keyBinds = {\n  \"W\": [0, -1],\n  \"A\": [-1, 0],\n  \"S\": [0, 1],\n  \"D\": [1, 0],\n  \"ARROWUP\": [0, -1],\n  \"ARROWLEFT\": [-1, 0],\n  \"ARROWDOWN\": [0, 1],\n  \"ARROWRIGHT\": [1, 0]\n};\n\nconst BOARD_X = 645;\nconst CANVAS_X = 800;\nconst CANVAS_Y = 645;\n\nclass GameView {\n  constructor(ctx) {\n    this.ctx = ctx;\n    this.board = new Board({\n      pos: [0, 0],\n      width: BOARD_X,\n      height: CANVAS_Y\n    });\n    this.game = new Game(this.ctx, this.board);\n    this.isPaused = false;\n    this.restartBuffer = 0;\n    this.restarted = false;\n    document.addEventListener('keydown', this.bindKeyHandlers.bind(this));\n    this.start();\n  }\n\n  start() {\n    setTimeout(() => {\n      this.intervalID = setInterval(() => this.step(), 20);\n    }, 1000);\n    this.game.resetChars();\n    if (this.restarted) {\n      this.board.resetBoard();\n      this.game.resetGame();\n      this.restarted = false;\n    }\n    this.game.render(this.ctx);\n    this.showText();\n    this.showIntro();\n  }\n\n  step() {\n    this.ctx.clearRect(0, 0, CANVAS_X, CANVAS_Y);\n    this.showText();\n    this.game.render(this.ctx);\n    if (this.game.gameOver) {\n      this.resetView();\n      setTimeout(() => this.showEndScreen(), 2000);\n    } else if (this.game.won) {\n      this.resetView();\n      setTimeout(() => this.showEndScreen(), 200);\n    } else if (this.game.lostLife) {\n      this.resetView();\n      setTimeout(() => this.start(), 1500);\n    }\n    this.game.moveChars(this.board.walls);\n    this.restartBuffer += 1; // prevent multiple restart presses and avoid asynchronicity issues\n  }\n\n  bindKeyHandlers(e) {\n    const key = e.key.toUpperCase();\n    if (key === \" \") {\n      if (this.isPaused) {\n        this.isPaused = false;\n        this.intervalID = setInterval(() => this.step(), 20);\n\n      } else if (this.restartBuffer > 0) {\n        window.clearInterval(this.intervalID);\n        this.isPaused = true;\n      }\n      this.restartBuffer = 0;\n    }\n    if (keyBinds[key]) {\n      this.game.chars[0].turn(keyBinds[key], this.board.walls);\n    }\n    if (key === \"Y\" && !this.game.chars[0].dying && (this.restartBuffer > 0 || this.isPaused)) {\n      this.resetView();\n      this.ctx.clearRect(0, 0, CANVAS_X, CANVAS_Y);\n      this.restarted = true;\n      this.restartBuffer = 0;\n      this.start();\n    }\n  }\n\n  resetView() {\n    window.clearInterval(this.intervalID);\n    this.game.lostLife = false;\n    this.restartBuffer = -1;\n  }\n\n  showText() {\n    this.showScore();\n    this.showLives();\n    this.showRestart();\n    this.showPause();\n  }\n\n  showIntro() {\n    this.ctx.fillStyle = \"black\";\n    this.ctx.fillRect(325, 345, 60, 15);\n    this.ctx.fillStyle = \"white\";\n    this.ctx.font = \"30px monospace\";\n    this.ctx.textAlign = \"center\";\n    this.ctx.fillText(\"READY?\", 325, 350);\n  }\n\n  showPause() {\n    const text = \"Spacebar to\";\n    const text2 = \"pause/resume\";\n    this.ctx.fillStyle = \"black\";\n    this.ctx.fillRect(650, 600, 50, 40);\n    this.ctx.fillStyle = \"white\";\n    this.ctx.font = \"16px monospace\";\n    this.ctx.textAlign = \"left\";\n    this.ctx.fillText(text, 660, 620, 130);\n    this.ctx.fillText(text2, 660, 640, 130);\n  }\n\n  showRestart() {\n    const text = \"Press Y\";\n    const text2 = \"to restart\";\n    this.ctx.fillStyle = \"black\";\n    this.ctx.fillRect(650, 560, 50, 40);\n    this.ctx.fillStyle = \"white\";\n    this.ctx.font = \"16px monospace\";\n    this.ctx.textAlign = \"left\";\n    this.ctx.fillText(text, 660, 560, 130);\n    this.ctx.fillText(text2, 660, 580, 130);\n  }\n\n  showLives() {\n    this.ctx.fillStyle = \"black\";\n    this.ctx.fillRect(660, 365, 200, 25);\n    this.ctx.fillStyle = \"white\";\n    this.ctx.font = \"18px monospace\";\n    this.ctx.textAlign = \"left\";\n    this.ctx.fillText(\"Lives: \" + parseInt(this.game.lives), 660, 365);\n  }\n\n  showScore() {\n    this.ctx.fillStyle = \"black\";\n    this.ctx.fillRect(660, 330, 150, 25);\n    this.ctx.fillStyle = \"white\";\n    this.ctx.font = \"18px monospace\";\n    this.ctx.textAlign = \"left\";\n    this.ctx.fillText(\"Score: \" + parseInt(this.game.score), 660, 330);\n  }\n\n  showEndScreen() {\n    this.game.chars[0].dying = false;\n    this.ctx.clearRect(0, 0, 1000, CANVAS_Y);\n    this.ctx.fillStyle = \"black\";\n    this.ctx.fillRect(320, 350, 80, 15);\n    this.ctx.fillStyle = \"white\";\n    this.ctx.font = \"32px monospace\";\n    this.ctx.textAlign = \"center\";\n\n    const text = this.game.gameOver ? \"You Lose...\" : \"You Won!\";\n    const score = `Score: ${this.game.score}`;\n    this.ctx.fillText(text, 320, 320);\n    this.ctx.fillText(score, 320, 380);\n    setTimeout(() => {\n      this.ctx.clearRect(0, 0, 1000, CANVAS_Y);\n      this.ctx.fillStyle = \"black\";\n      this.ctx.fillRect(320, 350, 80, 15);\n      this.ctx.fillStyle = \"white\";\n      this.ctx.font = \"32px monospace\";\n      this.ctx.textAlign = \"center\";\n      this.ctx.fillText(\"Play Again? (Press Y)\", 320, 350);\n      setTimeout(() => {\n        this.restartBuffer += 1;\n      }, 50);\n    }, 2000);\n  }\n}\n\n\nmodule.exports = GameView;\n\n//# sourceURL=webpack:///./lib/game_view.js?");

/***/ }),

/***/ "./lib/ghost.js":
/*!**********************!*\
  !*** ./lib/ghost.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const MovingObject = __webpack_require__(/*! ./moving_object */ \"./lib/moving_object.js\");\n\nconst DEFAULTS = {\n  dir: [-1, 0],\n  vel: 2,\n  radius: 15,\n  isFrightened: false,\n  isDead: false,\n  moveShift: false,\n  gridSize: 40,\n  wallSize: 4,\n  boardSize: 800\n};\n\nclass Ghost extends MovingObject {\n  constructor(options) {\n    options.dir = DEFAULTS.dir;\n    options.vel = DEFAULTS.vel;\n    options.radius = DEFAULTS.radius;\n    super(options);\n    this.startPos = this.pos;\n    this.name = options.name;\n    this.beerman = options.beerman;\n    this.isFrightened = DEFAULTS.isFrightened;\n    this.isDead = DEFAULTS.isDead;\n    this.moveShift = DEFAULTS.moveShift;\n    this.frightenedColor = \"#000080\";\n    this.numSteps = 0;\n    if (this.name === \"inky\") {\n      this.blinky = options.blinky;\n    }\n  }\n\n  render(ctx) {\n    if (!this.isDead) {\n      this.isFrightened = this.beerman.poweredUp;\n    }\n    if (this.isFrightened || this.isDead) {\n      ctx.fillStyle = this.frightenedColor;\n    } else {\n      ctx.fillStyle = this.color;\n    }\n    ctx.beginPath();\n\n    // main body\n    const centerPos = [this.pos[0] + DEFAULTS.gridSize / 2 + DEFAULTS.wallSize / 2, this.pos[1] + DEFAULTS.gridSize / 2 + DEFAULTS.wallSize / 2];\n    ctx.arc(centerPos[0], centerPos[1], this.radius, Math.PI, 0);\n    ctx.moveTo(centerPos[0] - this.radius, centerPos[1]);\n    if (this.moveShift) {\n      ctx.lineTo(centerPos[0] - this.radius, centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] - this.radius * (3 / 4), centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] - this.radius / 2, centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] - this.radius / 4, centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0], centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] + this.radius / 4, centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] + this.radius / 2, centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] + this.radius * (3 / 4), centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] + this.radius, centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] + this.radius, centerPos[1]);\n    } else {\n      ctx.lineTo(centerPos[0] - this.radius, centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] - this.radius * (3 / 4), centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] - this.radius / 2, centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] - this.radius / 4, centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0], centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] + this.radius / 4, centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] + this.radius / 2, centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] + this.radius * (3 / 4), centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] + this.radius, centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] + this.radius, centerPos[1]);\n    }\n    ctx.fill();\n\n    // eyes and mouth\n    if (!this.isFrightened && !this.isDead) {\n      ctx.fillStyle = \"white\";\n      ctx.beginPath();\n      ctx.arc(centerPos[0] - this.radius / 2.5, centerPos[1] - this.radius / 5, this.radius / 3, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.fillStyle = \"white\";\n      ctx.beginPath();\n      ctx.arc(centerPos[0] + this.radius / 2.5, centerPos[1] - this.radius / 5, this.radius / 3, 0, 2 * Math.PI);\n      ctx.fill();\n\n\n      if (this.dir[0] === -1 && this.dir[1] === 0) {\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] - this.radius / 3 - this.radius / 5, centerPos[1] - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] + this.radius / 3 - this.radius / 10, centerPos[1] - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n      } else if (this.dir[0] === 0 && this.dir[1] === -1) {\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] - this.radius / 3, centerPos[1] - this.radius / 5 - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] + this.radius / 3, centerPos[1] - this.radius / 5 - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n      } else if (this.dir[0] === 1 && this.dir[1] === 0) {\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] - this.radius / 3 + this.radius / 10, centerPos[1] - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] + this.radius / 3 + this.radius / 5, centerPos[1] - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n      } else if (this.dir[0] === 0 && this.dir[1] === 1) {\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] - this.radius / 3, centerPos[1] - this.radius / 5 + this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] + this.radius / 3, centerPos[1] - this.radius / 5 + this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n    } else {\n      if (this.isFrightened) {\n        ctx.fillStyle = \"white\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] - this.radius / 2.5, centerPos[1] - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"white\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] + this.radius / 2.5, centerPos[1] - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n\n        ctx.strokeStyle = \"white\";\n        ctx.beginPath();\n        ctx.lineWidth = 1;\n        ctx.moveTo(centerPos[0] - this.radius * 3 / 4, centerPos[1] + this.radius / 2);\n        ctx.lineTo(centerPos[0] - this.radius / 2, centerPos[1] + this.radius / 4);\n        ctx.lineTo(centerPos[0], centerPos[1] + this.radius / 2);\n        ctx.lineTo(centerPos[0] + this.radius / 2, centerPos[1] + this.radius / 4);\n        ctx.lineTo(centerPos[0] + this.radius * 3 / 4, centerPos[1] + this.radius / 2);\n        ctx.stroke();\n      } else {\n        ctx.fillStyle = \"white\";\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(centerPos[0] - this.radius / 2, centerPos[1] - this.radius / 2);\n        ctx.lineTo(centerPos[0] - this.radius / 4, centerPos[1] - this.radius / 4);\n        ctx.moveTo(centerPos[0] - this.radius / 4, centerPos[1] - this.radius / 2);\n        ctx.lineTo(centerPos[0] - this.radius / 2, centerPos[1] - this.radius / 4);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(centerPos[0] + this.radius / 2, centerPos[1] - this.radius / 2);\n        ctx.lineTo(centerPos[0] + this.radius / 4, centerPos[1] - this.radius / 4);\n        ctx.moveTo(centerPos[0] + this.radius / 4, centerPos[1] - this.radius / 2);\n        ctx.lineTo(centerPos[0] + this.radius / 2, centerPos[1] - this.radius / 4);\n        ctx.stroke();\n      }\n    }\n  }\n\n  move(walls) {\n    if (this.name === \"blinky\") {\n      if (this.isFrightened) {\n        this.target([DEFAULTS.boardSize, 0], walls);\n      } else {\n        this.target(this.beerman.pos, walls);\n      }\n    } else if (this.name === \"pinky\") {\n      if (this.isFrightened) {\n        this.target([0, 0], walls);\n      } else {\n        this.target([\n          this.beerman.pos[0] + this.beerman.dir[0] * DEFAULTS.gridSize * 4,\n          this.beerman.pos[0] + this.beerman.dir[0] * DEFAULTS.gridSize * 4,\n        ], walls);\n      }\n    } else if (this.name === \"inky\") {\n      if (this.isFrightened) {\n        this.target([DEFAULTS.boardSize, DEFAULTS.boardSize], walls);\n      } else {\n        const bmanTwoTiles = [\n          this.beerman.pos[0] + this.beerman.dir[0] * DEFAULTS.gridSize * 2,\n          this.beerman.pos[0] + this.beerman.dir[0] * DEFAULTS.gridSize * 2\n        ];\n        const inkyTarget = [2 * bmanTwoTiles[0] - this.blinky.pos[0], 2 * bmanTwoTiles[1] - this.blinky.pos[1]];\n        this.target(inkyTarget, walls);\n      }\n    } else if (this.name === \"clyde\") {\n      if (this.isFrightened) {\n        this.target([0, DEFAULTS.boardSize], walls);\n      } else {\n        const distFromBMan = Math.sqrt(\n          Math.pow(this.pos[0] - this.beerman.pos[0], 2)\n          + Math.pow(this.pos[1] - this.beerman.pos[1], 2)\n        );\n        if (distFromBMan > 200) {\n          this.target([0, DEFAULTS.gridSize + 100], walls);\n        } else {\n          this.target(this.beerman.pos, walls);\n        }\n      }\n    }\n    this.numSteps += 1;\n    if (this.numSteps >= 10) {\n      this.moveShift = !(this.moveShift);\n      this.numSteps = 0;\n    }\n    this.wrap();\n  }\n\n  // target(targetPos, tiles) {\n  //   if (this.pos[0] % DEFAULTS.gridSize === 0 && this.pos[1] % DEFAULTS.gridSize === 0) {\n  //     // up, left, down, right\n  //     const dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]];\n  //     const moveDistances = [];\n  //     const nextTiles = [];\n  //     const list = [];\n  //     dirs.forEach(dir => {\n  //       const nextPos = [\n  //         this.pos[0] + dir[0] * DEFAULTS.gridSize,\n  //         this.pos[1] + dir[1] * DEFAULTS.gridSize\n  //       ];\n  //       if (this.inBounds(nextPos)) {\n  //         const distToTarget = this.calcDist(nextPos, targetPos);\n  //         moveDistances.push(distToTarget);\n  //         const nextTile = [nextPos[0] / DEFAULTS.gridSize, nextPos[1] / DEFAULTS.gridSize];\n  //         nextTiles.push(nextTile);\n  //         list.push({ 'dir': dir, 'dist': distToTarget, 'tile': nextTile });\n  //       }\n  //     });\n\n  //     list.sort(function (a, b) {\n  //       return ((a.dist < b.dist) ? -1 : ((a.dist === b.dist) ? 0 : 1));\n  //     });\n  //     for (let i = 0; i < list.length; i++) {\n  //       dirs[i] = list[i].dir;\n  //       moveDistances[i] = list[i].dist;\n  //       nextTiles[i] = list[i].tile;\n  //     }\n\n  //     let selectedDir;\n  //     for (let j = 0; j < dirs.length; j++) {\n  //       let nextTile = nextTiles[j];\n  //       if (tiles[nextTile[1]][nextTile[0]] === 1) {\n  //         selectedDir = dirs[j];\n  //         break;\n  //       }\n  //     }\n  //     this.dir = selectedDir;\n  //     if (this.name === \"blinky\") {\n  //     }\n  //   }\n  //   this.moveOnce();\n  // }\n\n  calcDist(pos1, pos2) {\n    return Math.sqrt(Math.pow(pos1[0] - pos2[0], 2) + Math.pow(pos1[1] - pos2[1], 2));\n  }\n\n  inBounds(pos) {\n    return (\n      pos[0] >= 0 &&\n      pos[1] >= 0 &&\n      pos[0] <= (DEFAULTS.boardSize - DEFAULTS.gridSize) &&\n      pos[0] <= (DEFAULTS.boardSize - DEFAULTS.gridSize)\n    );\n  }\n\n  target(pos, walls) {\n    const xDif = this.pos[0] - pos[0];\n    const yDif = this.pos[1] - pos[1];\n    if (this.pos[0] % DEFAULTS.gridSize === 0 && this.pos[1] % DEFAULTS.gridSize === 0) {\n      if (Math.abs(xDif) >= Math.abs(yDif)) {\n        if (!this.tryXMove(xDif, walls, false)) this.tryYMove(yDif, walls, true);\n      }\n      if (Math.abs(yDif) > Math.abs(xDif)) {\n        if (!this.tryYMove(yDif, walls, false)) this.tryXMove(xDif, walls, true);\n      }\n    } else {\n      this.moveOnce();\n    }\n  }\n\n  tryXMove(xDif, walls, retry) {\n    if (xDif >= 0 && !this.willCollide([-1, 0], walls, !this.checkDirEquality([-1, 0], this.dir))) {\n      this.dir = [-1, 0];\n      this.moveOnce();\n      return true;\n    } else if (xDif < 0 && !this.willCollide([1, 0], walls, !this.checkDirEquality([1, 0], this.dir))) {\n      this.dir = [1, 0];\n      this.moveOnce();\n      return true;\n    } else {\n      if (retry) {\n        this.moveRandomly(walls);\n      } else {\n        return false;\n      }\n    }\n  }\n\n  tryYMove(yDif, walls, retry) {\n    if (yDif >= 0 && !this.willCollide([0, -1], walls, !this.checkDirEquality([0, -1], this.dir))) {\n      this.dir = [0, -1];\n      this.moveOnce();\n    } else if (yDif < 0 && !this.willCollide([0, 1], walls, !this.checkDirEquality([0, 1], this.dir))) {\n      this.dir = [0, 1];\n      this.moveOnce();\n    } else {\n      if (retry) {\n        this.moveRandomly(walls);\n      } else {\n        return false;\n      }\n    }\n  }\n\n  checkDirEquality(dir1, dir2) {\n    return (dir1[0] === dir2[0] && dir1[1] === dir2[1]);\n  }\n\n  moveOnce() {\n    this.pos = [this.pos[0] + this.dir[0] * this.vel, this.pos[1] + this.dir[1] * this.vel];\n  }\n\n  moveRandomly(walls) {\n    const dirs = [[-1, 0], [0, -1], [1, 0], [0, 1]];\n    const randomDir = dirs[Math.floor(Math.random() * 4)];\n    if (this.willCollide(randomDir, walls, !this.checkDirEquality(randomDir, this.dir))) {\n      this.moveRandomly(walls);\n    } else {\n      this.dir = randomDir;\n      this.moveOnce();\n    }\n  }\n\n  die(ctx) {\n    this.isFrightened = false;\n    this.isDead = true;\n    this.render(ctx);\n    this.pos = [this.startPos[0], this.startPos[1] + DEFAULTS.gridSize];\n    this.vel = 0;\n    setTimeout(() => {\n      this.pos = this.startPos;\n      this.vel = DEFAULTS.vel;\n      this.isDead = false;\n    }, 10000);\n  }\n}\n\nmodule.exports = Ghost;\n\n//# sourceURL=webpack:///./lib/ghost.js?");

/***/ }),

/***/ "./lib/moving_object.js":
/*!******************************!*\
  !*** ./lib/moving_object.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const gridSize = 40;\nconst wallSize = 4;\nconst canvasSize = 640;\nclass MovingObject {\n  constructor({ pos, dir, vel, radius, color, board }) {\n    this.pos = pos;\n    this.dir = dir;\n    this.vel = vel;\n    this.radius = radius;\n    this.color = color;\n    this.board = board;\n    this.queuedDir = undefined;\n    this.willCollide = this.willCollide.bind(this);\n  }\n\n  willCollide(dir, walls, turning) {\n    const pos = this.pos;\n    const leftWalls = walls[\"LEFT\"];\n    const topWalls = walls[\"TOP\"];\n    const rightWalls = walls[\"RIGHT\"];\n    const bottomWalls = walls[\"BOTTOM\"];\n    const notCentered = (this.pos[0] % gridSize !== 0 || this.pos[1] % gridSize !== 0);\n    const aboveGhostHome = (this.pos[0] >= gridSize * 7 && this.pos[0] <= gridSize * 8 && this.pos[1] >= gridSize * 6 && this.pos[1] <= gridSize * 7);\n    if (!turning) {\n      if (dir[0] === -1 && dir[1] === 0) {\n        return this.includesArr(leftWalls, pos) || this.includesArr(rightWalls, [this.pos[0] - gridSize, this.pos[1]]);\n      } else if (dir[0] === 0 && dir[1] === -1) {\n        return this.includesArr(topWalls, pos) || this.includesArr(bottomWalls, [this.pos[0], this.pos[1] - gridSize]);\n      } else if (dir[0] === 1 && dir[1] === 0) {\n        return this.includesArr(rightWalls, pos) || this.includesArr(leftWalls, [this.pos[0] + gridSize, this.pos[1]]);\n      } else if (dir[0] === 0 && dir[1] === 1) {\n        return aboveGhostHome || this.includesArr(bottomWalls, pos) || this.includesArr(topWalls, [this.pos[0], this.pos[1] + gridSize]);\n      }\n    } else {\n      if (dir[0] === -1 && dir[1] === 0) {\n        return (\n          (notCentered && this.includesArr(bottomWalls, [Math.floor((this.pos[0] - gridSize) / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize])) ||\n          (notCentered && this.includesArr(topWalls, [Math.floor((this.pos[0] - gridSize) / gridSize) * gridSize, Math.floor((this.pos[1] + gridSize) / gridSize) * gridSize])) ||\n          this.includesArr(leftWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(leftWalls, [Math.ceil(this.pos[0] / gridSize) * gridSize, Math.ceil(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(rightWalls, [Math.floor((this.pos[0] - gridSize) / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(rightWalls, [Math.ceil((this.pos[0] - gridSize) / gridSize) * gridSize, Math.ceil(this.pos[1] / gridSize) * gridSize])\n        );\n      } else if (dir[0] === 0 && dir[1] === -1) {\n        return (\n          (notCentered && this.includesArr(rightWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor((this.pos[1] - gridSize) / gridSize) * gridSize])) ||\n          (notCentered && this.includesArr(leftWalls, [Math.floor((this.pos[0] + gridSize) / gridSize) * gridSize, Math.floor((this.pos[1] - gridSize) / gridSize) * gridSize])) ||\n          this.includesArr(topWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(topWalls, [Math.ceil(this.pos[0] / gridSize) * gridSize, Math.ceil(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(bottomWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor((this.pos[1] - gridSize) / gridSize) * gridSize]) ||\n          this.includesArr(bottomWalls, [Math.ceil(this.pos[0] / gridSize) * gridSize, Math.ceil((this.pos[1] - gridSize) / gridSize) * gridSize])\n        );\n      } else if (dir[0] === 1 && dir[1] === 0) {\n        return (\n          (notCentered && this.includesArr(bottomWalls, [Math.floor((this.pos[0] + gridSize) / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize])) ||\n          (notCentered && this.includesArr(topWalls, [Math.floor((this.pos[0] + gridSize) / gridSize) * gridSize, Math.floor((this.pos[1] + gridSize) / gridSize) * gridSize])) ||\n          this.includesArr(rightWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(rightWalls, [Math.ceil(this.pos[0] / gridSize) * gridSize, Math.ceil(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(leftWalls, [Math.floor((this.pos[0] + gridSize) / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(leftWalls, [Math.ceil((this.pos[0] + gridSize) / gridSize) * gridSize, Math.ceil(this.pos[1] / gridSize) * gridSize])\n        );\n      } else if (dir[0] === 0 && dir[1] === 1) {\n        return (\n          aboveGhostHome ||\n          (notCentered && this.includesArr(rightWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor((this.pos[1] + gridSize) / gridSize) * gridSize])) ||\n          (notCentered && this.includesArr(leftWalls, [Math.floor((this.pos[0] + gridSize) / gridSize) * gridSize, Math.floor((this.pos[1] + gridSize) / gridSize) * gridSize])) ||\n          this.includesArr(bottomWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(bottomWalls, [Math.ceil(this.pos[0] / gridSize) * gridSize, Math.ceil(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(topWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor((this.pos[1] + gridSize) / gridSize) * gridSize]) ||\n          this.includesArr(topWalls, [Math.ceil(this.pos[0] / gridSize) * gridSize, Math.ceil((this.pos[1] + gridSize) / gridSize) * gridSize])\n        );\n      }\n    }\n  }\n\n  includesArr(mainArr, subArr) {\n    for (let i = 0; i < mainArr.length; i++) {\n      if (JSON.stringify(mainArr[i]) === JSON.stringify(subArr)) return true;\n    }\n    return false;\n  }\n\n  move(walls) {\n    if (this.queuedDir && !this.willCollide(this.queuedDir, walls, true)) {\n      this.dir = this.queuedDir;\n      this.queuedDir = undefined;\n    }\n    if (!this.willCollide(this.dir, walls, false)) {\n      this.pos = [this.pos[0] + this.dir[0] * this.vel, this.pos[1] + this.dir[1] * this.vel];\n    }\n    this.wrap();\n  }\n\n  turn(dir, walls) {\n    if (!this.willCollide(dir, walls, true)) {\n      this.dir = dir;\n      this.queuedDir = undefined;\n    } else {\n      this.queuedDir = dir;\n    }\n  }\n\n  wrap() {\n    if (this.pos[0] < 0 && (this.dir[0] === -1 && this.dir[1] === 0)) {\n      this.pos = [canvasSize - gridSize / 2, this.pos[1]];\n    } else if (this.pos[0] > canvasSize - gridSize / 2 && (this.dir[0] === 1 && this.dir[1] === 0)) {\n      this.pos = [-gridSize / 2, this.pos[1]];\n    }\n  }\n}\n\nmodule.exports = MovingObject;\n\n//# sourceURL=webpack:///./lib/moving_object.js?");

/***/ })

/******/ });