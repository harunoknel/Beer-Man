/******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
      /******/
    }
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
      /******/
    };
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
    /******/
  }
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function (exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
      /******/
    }
    /******/
  };
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function (exports) {
/******/ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      /******/
    }
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
    /******/
  };
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function (value, mode) {
/******/ 		if (mode & 1) value = __webpack_require__(value);
/******/ 		if (mode & 8) return value;
/******/ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
    /******/
  };
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function (module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
    /******/
  };
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/entry.js");
  /******/
})
/************************************************************************/
/******/({

/***/ "./lib/beerman.js":
/*!************************!*\
  !*** ./lib/beerman.js ***!
  \************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

        eval("const MovingObject = __webpack_require__(/*! ./moving_object */ \"./lib/moving_object.js\");\n\nconst DEFAULTS = {\n  pos: [400, 450],\n  dir: [1, 0],\n  vel: 5,\n  radius: 18,\n  gridSize: 40,\n  wallSize: 4\n};\n\nclass Beerman extends MovingObject {\n  constructor(options) {\n    options.pos = DEFAULTS.pos;\n    options.dir = DEFAULTS.dir;\n    options.vel = DEFAULTS.vel;\n    options.radius = DEFAULTS.radius;\n    super(options);\n    this.numBeers = 0;\n    this.openMouth = true;\n    this.poweredUp = false;\n    this.numSteps = 0;\n    this.drawState = this.drawState.bind(this);\n    this.score = 0;\n  }\n\n  drink() {\n    if (this.pos[0] % DEFAULTS.gridSize === 0 && this.pos[0] % DEFAULTS.gridSize === 0) {\n      const row = Math.floor(this.pos[1] / DEFAULTS.gridSize);\n      const col = Math.floor(this.pos[0] / DEFAULTS.gridSize);\n      if (this.board.drinkLocations[row][col] === 1) {\n        this.board.removeDrink(Math.floor(this.pos[1] / DEFAULTS.gridSize), Math.floor(this.pos[0] / DEFAULTS.gridSize));\n        this.numBeers += 1;\n        this.score += 100;\n        this.vel = DEFAULTS.vel * Math.pow((1 / 2), (Math.floor(this.numBeers / (DEFAULTS.gridSize / 2))));\n        if (this.vel !== DEFAULTS.vel) {\n          this.color = \"green\";\n        }\n      } else if (this.board.drinkLocations[row][col] === 2) {\n        this.board.removeDrink(Math.floor(this.pos[1] / DEFAULTS.gridSize), Math.floor(this.pos[0] / DEFAULTS.gridSize));\n        this.pos = [Math.floor(this.pos[0] / DEFAULTS.wallSize) * DEFAULTS.wallSize, Math.floor(this.pos[1] / DEFAULTS.wallSize) * DEFAULTS.wallSize];\n        this.numBeers = 0;\n        this.vel = DEFAULTS.vel;\n        this.color = \"yellow\";\n        this.poweredUp = true;\n        this.score += 500;\n        setTimeout(() => {\n          this.poweredUp = false;\n        }, 10000);\n      }\n    }\n  }\n\n  render(ctx) {\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    const centerPos = [this.pos[0] + DEFAULTS.gridSize / 2 + DEFAULTS.wallSize / 2, this.pos[1] + DEFAULTS.gridSize / 2 + DEFAULTS.wallSize / 2];\n    if (this.openMouth) {\n      if (this.dir[0] === -1 && this.dir[1] === 0) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 7 / 9, 2 * Math.PI - Math.PI * 11 / 9);\n      } else if (this.dir[0] === 0 && this.dir[1] === -1) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 2 / 9, 2 * Math.PI - Math.PI * 7 / 9);\n      } else if (this.dir[0] === 1 && this.dir[1] === 0) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 16 / 9, 2 * Math.PI - Math.PI * 2 / 9);\n      } else if (this.dir[0] === 0 && this.dir[1] === 1) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 11 / 9, 2 * Math.PI - Math.PI * 16 / 9);\n      }\n    } else {\n      if (this.dir[0] === -1 && this.dir[1] === 0) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 17 / 18, 2 * Math.PI - Math.PI * 19 / 18);\n      } else if (this.dir[0] === 0 && this.dir[1] === -1) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 8 / 18, 2 * Math.PI - Math.PI * 10 / 18);\n      } else if (this.dir[0] === 1 && this.dir[1] === 0) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 35 / 18, 2 * Math.PI - Math.PI * 1 / 18);\n      } else if (this.dir[0] === 0 && this.dir[1] === 1) {\n        ctx.arc(centerPos[0], centerPos[1], this.radius, 2 * Math.PI - Math.PI * 26 / 18, 2 * Math.PI - Math.PI * 28 / 18);\n      }\n    }\n    ctx.lineTo(centerPos[0], centerPos[1]);\n    ctx.fill();\n    this.numSteps += 1;\n    if (this.numSteps >= 10) {\n      this.openMouth = !(this.openMouth);\n      this.numSteps = 0;\n    }\n  }\n\n  die(ctx) {\n    ctx.fillStyle = this.color;\n    const centerPos = [this.pos[0] + DEFAULTS.gridSize / 2 + DEFAULTS.wallSize / 2, this.pos[1] + DEFAULTS.gridSize / 2 + DEFAULTS.wallSize / 2];\n\n    setTimeout(() => {\n      this.drawState(ctx, centerPos, [2 * Math.PI - Math.PI * 17 / 18, 2 * Math.PI - Math.PI * 19 / 18]);\n      setTimeout(() => {\n        this.drawState(ctx, centerPos, [2 * Math.PI - Math.PI * 8 / 18, 2 * Math.PI - Math.PI * 10 / 18]);\n        setTimeout(() => {\n          this.drawState(ctx, centerPos, [2 * Math.PI - Math.PI * 35 / 18, 2 * Math.PI - Math.PI * 1 / 18]);\n          setTimeout(() => {\n            this.drawState(ctx, centerPos, [2 * Math.PI - Math.PI * 26 / 18, 2 * Math.PI - Math.PI * 28 / 18]);\n          }, 200);\n        }, 200);\n      }, 200);\n    }, 200);\n  }\n\n  drawState(ctx, centerPos, angles) {\n    this.board.render(ctx);\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    ctx.arc(centerPos[0], centerPos[1], this.radius, angles[0], angles[1]);\n    ctx.lineTo(centerPos[0], centerPos[1]);\n    ctx.fill();\n  }\n}\n\nmodule.exports = Beerman;\n\n//# sourceURL=webpack:///./lib/beerman.js?");

        /***/
      }),

/***/ "./lib/board.js":
/*!**********************!*\
  !*** ./lib/board.js ***!
  \**********************/
/*! no static exports found */
/***/ (function (module, exports) {

        eval("class Board {\n  constructor(options) {\n    this.pos = options.pos;\n    this.width = options.width;\n    this.height = options.height;\n    this.numRows = 16;\n    this.numCols = this.numRows;\n    this.walls = {\n      \"LEFT\": [],\n      \"TOP\": [],\n      \"RIGHT\": [],\n      \"BOTTOM\": []\n    };\n    this.drinkLocations = DRINK_LOCATIONS;\n    this.tiles = TILES;\n  }\n\n  render(ctx) {\n    this.resetWalls();\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(this.pos[0], this.pos[1], this.width, this.height);\n    for (let row = 0; row < this.numRows; row++) {\n      for (let col = 0; col < this.numCols; col++) {\n        if (this.drinkLocations[row][col] === 1) {\n          this.drawBeer(ctx, row, col);\n        }\n        if (this.drinkLocations[row][col] === 2) {\n          this.drawCoffee(ctx, row, col);\n        }\n        switch (EDGES[row][col]) {\n          case LEFT:\n            this.drawLeftEdge(ctx, row, col);\n            break;\n          case TOP:\n            this.drawTopEdge(ctx, row, col);\n            break;\n          case RIGHT:\n            this.drawRightEdge(ctx, row, col);\n            break;\n          case BOTTOM:\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case LEFT_TOP:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawTopEdge(ctx, row, col);\n            break;\n          case LEFT_RIGHT:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawRightEdge(ctx, row, col);\n            break;\n          case LEFT_BOTTOM:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case TOP_RIGHT:\n            this.drawTopEdge(ctx, row, col);\n            this.drawRightEdge(ctx, row, col);\n            break;\n          case TOP_BOTTOM:\n            this.drawTopEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case RIGHT_BOTTOM:\n            this.drawRightEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case LEFT_TOP_RIGHT:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawTopEdge(ctx, row, col);\n            this.drawRightEdge(ctx, row, col);\n            break;\n          case TOP_RIGHT_BOTTOM:\n            this.drawTopEdge(ctx, row, col);\n            this.drawRightEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case LEFT_BOTTOM_RIGHT:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            this.drawRightEdge(ctx, row, col);\n            break;\n          case LEFT_TOP_BOTTOM:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawTopEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case FOUR_SIDES:\n            this.drawLeftEdge(ctx, row, col);\n            this.drawTopEdge(ctx, row, col);\n            this.drawRightEdge(ctx, row, col);\n            this.drawBottomEdge(ctx, row, col);\n            break;\n          case EMPTY:\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }\n\n  drawBeer(ctx, row, col) {\n    ctx.font = \"25px Arial\";\n    ctx.fillText(String.fromCodePoint(0x1F37A), col * SIZES.gridSize + 16, row * SIZES.gridSize + 40);\n  }\n\n  drawCoffee(ctx, row, col) {\n    ctx.font = \"30px Arial\";\n    ctx.fillText(String.fromCodePoint(0x2615), col * SIZES.gridSize + 13, row * SIZES.gridSize + 40);\n  }\n\n  drawLeftEdge(ctx, row, col) {\n    ctx.fillStyle = \"blue\";\n    const pos = [col * SIZES.gridSize, row * SIZES.gridSize];\n    ctx.fillRect(\n      pos[0],\n      pos[1],\n      SIZES.wall,\n      SIZES.gridSize + SIZES.wall\n    );\n    this.storeWalls(pos, \"LEFT\");\n  }\n\n\n  drawTopEdge(ctx, row, col) {\n    ctx.fillStyle = \"blue\";\n    const pos = [col * SIZES.gridSize, row * SIZES.gridSize];\n    ctx.fillRect(\n      pos[0],\n      pos[1],\n      SIZES.gridSize,\n      SIZES.wall\n    );\n    this.storeWalls(pos, \"TOP\");\n  }\n\n  drawRightEdge(ctx, row, col) {\n    ctx.fillStyle = \"blue\";\n    const pos = [col * SIZES.gridSize, row * SIZES.gridSize];\n    ctx.fillRect(\n      pos[0] + SIZES.gridSize,\n      pos[1],\n      SIZES.wall,\n      SIZES.gridSize + SIZES.wall\n    );\n    this.storeWalls(pos, \"RIGHT\");\n  }\n\n  drawBottomEdge(ctx, row, col) {\n    ctx.fillStyle = \"blue\";\n    const pos = [col * SIZES.gridSize, row * SIZES.gridSize];\n    ctx.fillRect(\n      pos[0],\n      pos[1] + SIZES.gridSize,\n      SIZES.gridSize,\n      SIZES.wall\n    );\n    this.storeWalls(pos, \"BOTTOM\");\n  }\n\n  isEmpty() {\n    for (let row = 0; row < DRINK_LOCATIONS.length; row++) {\n      for (let col = 0; col < DRINK_LOCATIONS.length; col++) {\n        if (DRINK_LOCATIONS[row][col] > 0) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  removeDrink(row, col) {\n    this.drinkLocations[row][col] = 0;\n  }\n\n  resetWalls() {\n    this.walls = {\n      \"LEFT\": [],\n      \"TOP\": [],\n      \"RIGHT\": [],\n      \"BOTTOM\": []\n    };\n  }\n\n  storeWalls(pos, dir) {\n    this.walls[dir].push(pos);\n  }\n}\n\nconst SIZES = {\n  wall: 5,\n  gridSize: 40\n};\n\nconst LEFT = \"LEFT\";\nconst TOP = \"TOP\";\nconst RIGHT = \"RIGHT\";\nconst BOTTOM = \"BOTTOM\";\nconst LEFT_TOP = \"LEFT_TOP\";\nconst LEFT_RIGHT = \"LEFT_RIGHT\";\nconst LEFT_BOTTOM = \"LEFT_BOTTOM\";\nconst TOP_RIGHT = \"TOP_RIGHT\";\nconst TOP_BOTTOM = \"TOP_BOTTOM\";\nconst RIGHT_BOTTOM = \"RIGHT_BOTTOM\";\nconst LEFT_TOP_RIGHT = \"LEFT_TOP_RIGHT\";\nconst TOP_RIGHT_BOTTOM = \"TOP_RIGHT_BOTTOM\";\nconst LEFT_BOTTOM_RIGHT = \"LEFT_BOTTOM_RIGHT\";\nconst LEFT_TOP_BOTTOM = \"LEFT_TOP_BOTTOM\";\nconst FOUR_SIDES = \"FOUR_SIDES\";\nconst EMPTY = \"EMPTY\";\n\nconst EDGES = [\n  [LEFT_TOP, TOP_BOTTOM, TOP_BOTTOM, TOP, TOP_BOTTOM, TOP_BOTTOM, TOP_BOTTOM,\n    TOP_RIGHT, LEFT_TOP, TOP_BOTTOM, TOP_BOTTOM, TOP_BOTTOM, TOP, TOP_BOTTOM, TOP_BOTTOM, TOP_RIGHT],\n  [LEFT_RIGHT, BOTTOM, RIGHT_BOTTOM, RIGHT, BOTTOM, BOTTOM, RIGHT_BOTTOM, RIGHT,\n    RIGHT, BOTTOM, BOTTOM, RIGHT_BOTTOM, EMPTY, LEFT_BOTTOM, RIGHT_BOTTOM, RIGHT],\n  [LEFT, BOTTOM, BOTTOM, EMPTY, EMPTY, EMPTY, BOTTOM, BOTTOM,\n    BOTTOM, BOTTOM, EMPTY, EMPTY, EMPTY, BOTTOM, BOTTOM, RIGHT],\n  [LEFT, LEFT_BOTTOM, RIGHT_BOTTOM, RIGHT, LEFT_TOP, LEFT, LEFT_TOP_BOTTOM, TOP_BOTTOM,\n    TOP_BOTTOM, TOP_RIGHT_BOTTOM, EMPTY, LEFT_TOP_RIGHT, EMPTY, LEFT_TOP_BOTTOM, TOP_RIGHT_BOTTOM, RIGHT],\n  [LEFT_BOTTOM, BOTTOM, BOTTOM, RIGHT, EMPTY, LEFT_BOTTOM, BOTTOM, RIGHT, EMPTY, BOTTOM,\n    RIGHT_BOTTOM, RIGHT, EMPTY, BOTTOM, BOTTOM, RIGHT_BOTTOM],\n  [EMPTY, EMPTY, EMPTY, LEFT, LEFT, BOTTOM, RIGHT_BOTTOM, EMPTY,\n    LEFT, LEFT_BOTTOM, BOTTOM, RIGHT, RIGHT, EMPTY, EMPTY, EMPTY],\n  [EMPTY, EMPTY, EMPTY, LEFT, LEFT, LEFT, EMPTY, EMPTY,\n    EMPTY, EMPTY, RIGHT, RIGHT, RIGHT, EMPTY, EMPTY, EMPTY],\n  [EMPTY, EMPTY, RIGHT, EMPTY, LEFT_BOTTOM, LEFT, LEFT_TOP, EMPTY, EMPTY,\n    TOP_RIGHT, EMPTY, LEFT_RIGHT, RIGHT, EMPTY, EMPTY, EMPTY],\n  [TOP, TOP, TOP, EMPTY, EMPTY, EMPTY, LEFT_BOTTOM, BOTTOM,\n    BOTTOM, RIGHT_BOTTOM, EMPTY, TOP_BOTTOM, EMPTY, TOP, TOP, TOP],\n  [TOP, TOP, TOP_RIGHT, RIGHT, TOP_RIGHT, EMPTY, BOTTOM, BOTTOM, BOTTOM,\n    BOTTOM, RIGHT, RIGHT, EMPTY, LEFT_TOP, TOP, TOP],\n  [BOTTOM, BOTTOM, RIGHT_BOTTOM, RIGHT, RIGHT_BOTTOM, EMPTY, LEFT_BOTTOM,\n    BOTTOM, BOTTOM, RIGHT_BOTTOM, RIGHT, RIGHT_BOTTOM, RIGHT, BOTTOM, BOTTOM, BOTTOM],\n  [LEFT, BOTTOM, BOTTOM, EMPTY, BOTTOM, BOTTOM, BOTTOM, RIGHT, EMPTY, BOTTOM,\n    BOTTOM, BOTTOM, EMPTY, BOTTOM, BOTTOM, RIGHT],\n  [LEFT, LEFT_BOTTOM, RIGHT, EMPTY, LEFT_BOTTOM, BOTTOM, RIGHT_BOTTOM, RIGHT,\n    EMPTY, LEFT_BOTTOM, BOTTOM, RIGHT_BOTTOM, EMPTY, LEFT, RIGHT_BOTTOM, RIGHT],\n  [LEFT, RIGHT, RIGHT_BOTTOM, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,\n    EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, LEFT_BOTTOM, LEFT, RIGHT],\n  [LEFT_TOP, BOTTOM, BOTTOM, BOTTOM, LEFT_BOTTOM, TOP_BOTTOM, TOP_BOTTOM, TOP_RIGHT,\n    TOP, TOP_BOTTOM, TOP_BOTTOM, RIGHT_BOTTOM, BOTTOM, BOTTOM, BOTTOM, TOP_RIGHT],\n  [LEFT_BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM,\n    BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, RIGHT_BOTTOM]\n];\n\nconst DRINK_LOCATIONS = [\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [2, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 2],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1],\n  [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1],\n  [2, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 2],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n];\n\nconst TILES = [\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1],\n  [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],\n  [0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\n  [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1],\n  [0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1],\n  [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n];\n\n\nmodule.exports = Board;\n\n//# sourceURL=webpack:///./lib/board.js?");

        /***/
      }),

/***/ "./lib/entry.js":
/*!**********************!*\
  !*** ./lib/entry.js ***!
  \**********************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

        eval("const GameView = __webpack_require__(/*! ./game_view */ \"./lib/game_view.js\");\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n  canvasEl.height = 805;\n  canvasEl.width = 805;\n  const ctx = canvasEl.getContext(\"2d\");\n  const gview = new GameView(ctx);\n});\n\n\n//# sourceURL=webpack:///./lib/entry.js?");

        /***/
      }),

/***/ "./lib/game.js":
/*!*********************!*\
  !*** ./lib/game.js ***!
  \*********************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

        eval("const Beerman = __webpack_require__(/*! ./beerman */ \"./lib/beerman.js\");\nconst Ghost = __webpack_require__(/*! ./ghost */ \"./lib/ghost.js\");\nclass Game {\n\n  constructor(ctx, board) {\n    const beerman = new Beerman({ color: \"#FFFF00\", board });\n    const blinky = new Ghost({ pos: [300, 300], color: \"#FF0000\", board, beerman, name: \"blinky\" });\n    const pinky = new Ghost({ pos: [350, 300], color: \"#FF69B4\", board, beerman, name: \"pinky\" });\n    const inky = new Ghost({ pos: [400, 300], color: \"#00FFFF\", board, beerman, name: \"inky\", blinky: blinky });\n    const clyde = new Ghost({ pos: [450, 300], color: \"#FFA500\", board, beerman, name: \"clyde\" });\n    this.board = board;\n    this.objects = [beerman, blinky, pinky, inky, clyde];\n    this.gameOver = false;\n    this.won = false;\n    this.render(ctx);\n  }\n\n  render(ctx) {\n    let empty = false;\n    let caught = false;\n    this.board.render(ctx);\n    if (this.board.isEmpty()) {\n      empty = true;\n    }\n    const beermanPos = this.objects[0].pos;\n    this.objects.forEach((object, idx) => {\n      object.render(ctx);\n      if (idx >= 1 && this.checkCollision(object.pos, beermanPos)) {\n        if (this.objects[0].poweredUp) {\n          object.die(ctx);\n          this.objects[0].score += 1000;\n        } else {\n          caught = true;\n          this.objects[0].die(ctx);\n        }\n      }\n    });\n    this.won = empty;\n    this.gameOver = caught;\n  }\n\n  checkCollision(pos1, pos2) {\n    return ((Math.abs(pos1[0] - pos2[0]) <= 2.5) && Math.abs(pos1[1] - pos2[1]) <= 2.5);\n  }\n\n  moveObjects(walls, tiles) {\n    this.objects.forEach((object, idx) => {\n      if (idx === 0) {\n        object.drink();\n      }\n      object.move(walls, tiles);\n    });\n  }\n}\n\nmodule.exports = Game;\n\n//# sourceURL=webpack:///./lib/game.js?");

        /***/
      }),

/***/ "./lib/game_view.js":
/*!**************************!*\
  !*** ./lib/game_view.js ***!
  \**************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

        eval("const Board = __webpack_require__(/*! ./board */ \"./lib/board.js\");\nconst Game = __webpack_require__(/*! ./game */ \"./lib/game.js\");\n\nconst keyBinds = {\n  \"W\": [0, -1],\n  \"A\": [-1, 0],\n  \"S\": [0, 1],\n  \"D\": [1, 0],\n  \"ARROWUP\": [0, -1],\n  \"ARROWLEFT\": [-1, 0],\n  \"ARROWDOWN\": [0, 1],\n  \"ARROWRIGHT\": [1, 0]\n};\n\nconst DIM_X = 805;\nconst DIM_Y = 805;\n\nclass GameView {\n  constructor(ctx) {\n    this.ctx = ctx;\n    this.board = new Board({\n      pos: [0, 0],\n      width: DIM_X,\n      height: DIM_Y\n    });\n    this.game = new Game(this.ctx, this.board);\n    document.addEventListener('keydown', this.bindKeyHandlers.bind(this));\n    this.intervalID = setInterval(() => this.step(), 20);\n  }\n\n  step() {\n    this.ctx.clearRect(0, 0, DIM_X, DIM_Y);\n    this.game.render(this.ctx);\n    if (this.game.gameOver) {\n      window.clearInterval(this.intervalID);\n      console.log(\"You lose.\");\n    } else if (this.game.won) {\n      window.clearInterval(this.intervalID);\n      console.log(\"You win!\");\n    }\n    this.game.moveObjects(this.board.walls, this.board.tiles);\n  }\n\n  bindKeyHandlers(e) {\n    const key = e.key.toUpperCase();\n    if (keyBinds[key]) {\n      this.game.objects[0].turn(keyBinds[key], this.board.walls);\n    }\n  }\n}\n\nmodule.exports = GameView;\n\n//# sourceURL=webpack:///./lib/game_view.js?");

        /***/
      }),

/***/ "./lib/ghost.js":
/*!**********************!*\
  !*** ./lib/ghost.js ***!
  \**********************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

        eval("const MovingObject = __webpack_require__(/*! ./moving_object */ \"./lib/moving_object.js\");\n\nconst DEFAULTS = {\n  pos: [350, 300],\n  dir: [-1, 0],\n  vel: 2.5,\n  radius: 18,\n  isFrightened: false,\n  isDead: false,\n  moveShift: false,\n  gridSize: 40,\n  wallSize: 4,\n  boardSize: 800\n};\n\nclass Ghost extends MovingObject {\n  constructor(options) {\n    options.dir = DEFAULTS.dir;\n    options.vel = DEFAULTS.vel;\n    options.radius = DEFAULTS.radius;\n    super(options);\n    this.startPos = this.pos;\n    this.name = options.name;\n    this.beerman = options.beerman;\n    this.isFrightened = DEFAULTS.isFrightened;\n    this.isDead = DEFAULTS.isDead;\n    this.moveShift = DEFAULTS.moveShift;\n    this.frightenedColor = \"#000080\";\n    this.numSteps = 0;\n    if (this.name === \"inky\") {\n      this.blinky = options.blinky;\n    }\n  }\n\n  render(ctx) {\n    if (!this.isDead) {\n      this.isFrightened = this.beerman.poweredUp;\n    }\n    if (this.isFrightened || this.isDead) {\n      ctx.fillStyle = this.frightenedColor;\n    } else {\n      ctx.fillStyle = this.color;\n    }\n    ctx.beginPath();\n\n    // main body\n    const centerPos = [this.pos[0] + DEFAULTS.gridSize / 2 + DEFAULTS.wallSize / 2, this.pos[1] + DEFAULTS.gridSize / 2 + DEFAULTS.wallSize / 2];\n    ctx.arc(centerPos[0], centerPos[1], this.radius, Math.PI, 0);\n    ctx.moveTo(centerPos[0] - this.radius, centerPos[1]);\n    if (this.moveShift) {\n      ctx.lineTo(centerPos[0] - this.radius, centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] - this.radius * (3 / 4), centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] - this.radius / 2, centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] - this.radius / 4, centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0], centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] + this.radius / 4, centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] + this.radius / 2, centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] + this.radius * (3 / 4), centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] + this.radius, centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] + this.radius, centerPos[1]);\n    } else {\n      ctx.lineTo(centerPos[0] - this.radius, centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] - this.radius * (3 / 4), centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] - this.radius / 2, centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] - this.radius / 4, centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0], centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] + this.radius / 4, centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] + this.radius / 2, centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] + this.radius * (3 / 4), centerPos[1] + this.radius * 5 / 4);\n      ctx.lineTo(centerPos[0] + this.radius, centerPos[1] + this.radius);\n      ctx.lineTo(centerPos[0] + this.radius, centerPos[1]);\n    }\n    ctx.fill();\n\n    // eyes and mouth\n    if (!this.isFrightened && !this.isDead) {\n      ctx.fillStyle = \"white\";\n      ctx.beginPath();\n      ctx.arc(centerPos[0] - this.radius / 2.5, centerPos[1] - this.radius / 5, this.radius / 3, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.fillStyle = \"white\";\n      ctx.beginPath();\n      ctx.arc(centerPos[0] + this.radius / 2.5, centerPos[1] - this.radius / 5, this.radius / 3, 0, 2 * Math.PI);\n      ctx.fill();\n\n\n      if (this.dir[0] === -1 && this.dir[1] === 0) {\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] - this.radius / 3 - this.radius / 5, centerPos[1] - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] + this.radius / 3 - this.radius / 10, centerPos[1] - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n      } else if (this.dir[0] === 0 && this.dir[1] === -1) {\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] - this.radius / 3, centerPos[1] - this.radius / 5 - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] + this.radius / 3, centerPos[1] - this.radius / 5 - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n      } else if (this.dir[0] === 1 && this.dir[1] === 0) {\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] - this.radius / 3 + this.radius / 10, centerPos[1] - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] + this.radius / 3 + this.radius / 5, centerPos[1] - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n      } else if (this.dir[0] === 0 && this.dir[1] === 1) {\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] - this.radius / 3, centerPos[1] - this.radius / 5 + this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] + this.radius / 3, centerPos[1] - this.radius / 5 + this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n    } else {\n      if (this.isFrightened) {\n        ctx.fillStyle = \"white\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] - this.radius / 2.5, centerPos[1] - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.fillStyle = \"white\";\n        ctx.beginPath();\n        ctx.arc(centerPos[0] + this.radius / 2.5, centerPos[1] - this.radius / 5, this.radius / 6, 0, 2 * Math.PI);\n        ctx.fill();\n\n        ctx.strokeStyle = \"white\";\n        ctx.beginPath();\n        ctx.lineWidth = 1;\n        ctx.moveTo(centerPos[0] - this.radius * 3 / 4, centerPos[1] + this.radius / 2);\n        ctx.lineTo(centerPos[0] - this.radius / 2, centerPos[1] + this.radius / 4);\n        ctx.lineTo(centerPos[0], centerPos[1] + this.radius / 2);\n        ctx.lineTo(centerPos[0] + this.radius / 2, centerPos[1] + this.radius / 4);\n        ctx.lineTo(centerPos[0] + this.radius * 3 / 4, centerPos[1] + this.radius / 2);\n        ctx.stroke();\n      } else {\n        ctx.fillStyle = \"white\";\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(centerPos[0] - this.radius / 2, centerPos[1] - this.radius / 2);\n        ctx.lineTo(centerPos[0] - this.radius / 4, centerPos[1] - this.radius / 4);\n        ctx.moveTo(centerPos[0] - this.radius / 4, centerPos[1] - this.radius / 2);\n        ctx.lineTo(centerPos[0] - this.radius / 2, centerPos[1] - this.radius / 4);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(centerPos[0] + this.radius / 2, centerPos[1] - this.radius / 2);\n        ctx.lineTo(centerPos[0] + this.radius / 4, centerPos[1] - this.radius / 4);\n        ctx.moveTo(centerPos[0] + this.radius / 4, centerPos[1] - this.radius / 2);\n        ctx.lineTo(centerPos[0] + this.radius / 2, centerPos[1] - this.radius / 4);\n        ctx.stroke();\n      }\n    }\n  }\n\n  move(walls, tiles) {\n    if (this.name === \"blinky\") {\n      if (this.isFrightened) {\n        this.target([DEFAULTS.boardSize, 0], walls);\n      } else {\n        this.target(this.beerman.pos, walls);\n      }\n    } else if (this.name === \"pinky\") {\n      if (this.isFrightened) {\n        this.target([0, 0], walls);\n      } else {\n        this.target([\n          this.beerman.pos[0] + this.beerman.dir[0] * DEFAULTS.gridSize * 4,\n          this.beerman.pos[0] + this.beerman.dir[0] * DEFAULTS.gridSize * 4,\n        ], walls);\n      }\n    } else if (this.name === \"inky\") {\n      if (this.isFrightened) {\n        this.target([DEFAULTS.boardSize, DEFAULTS.boardSize], walls);\n      } else {\n        const bmanTwoTiles = [\n          this.beerman.pos[0] + this.beerman.dir[0] * DEFAULTS.gridSize * 2,\n          this.beerman.pos[0] + this.beerman.dir[0] * DEFAULTS.gridSize * 2\n        ];\n        const inkyTarget = [2 * bmanTwoTiles[0] - this.blinky.pos[0], 2 * bmanTwoTiles[1] - this.blinky.pos[1]];\n        this.target(inkyTarget, walls);\n      }\n    } else if (this.name === \"clyde\") {\n      if (this.isFrightened) {\n        this.target([0, DEFAULTS.boardSize], walls);\n      } else {\n        const distFromBMan = Math.sqrt(\n          Math.pow(this.pos[0] - this.beerman.pos[0], 2)\n          + Math.pow(this.pos[1] - this.beerman.pos[1], 2)\n        );\n        if (distFromBMan > 200) {\n          this.target([0, DEFAULTS.gridSize + 100], walls);\n        } else {\n          this.target(this.beerman.pos, walls);\n        }\n      }\n    }\n    this.numSteps += 1;\n    if (this.numSteps >= 10) {\n      this.moveShift = !(this.moveShift);\n      this.numSteps = 0;\n    }\n    this.wrap();\n  }\n\n  // target(targetPos, tiles) {\n  //   if (this.pos[0] % DEFAULTS.gridSize === 0 && this.pos[1] % DEFAULTS.gridSize === 0) {\n  //     // up, left, down, right\n  //     const dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]];\n  //     const moveDistances = [];\n  //     const nextTiles = [];\n  //     const list = [];\n  //     dirs.forEach(dir => {\n  //       const nextPos = [\n  //         this.pos[0] + dir[0] * DEFAULTS.gridSize,\n  //         this.pos[1] + dir[1] * DEFAULTS.gridSize\n  //       ];\n  //       if (this.inBounds(nextPos)) {\n  //         const distToTarget = this.calcDist(nextPos, targetPos);\n  //         moveDistances.push(distToTarget);\n  //         const nextTile = [nextPos[0] / DEFAULTS.gridSize, nextPos[1] / DEFAULTS.gridSize];\n  //         nextTiles.push(nextTile);\n  //         list.push({ 'dir': dir, 'dist': distToTarget, 'tile': nextTile });\n  //       }\n  //     });\n\n  //     list.sort(function (a, b) {\n  //       return ((a.dist < b.dist) ? -1 : ((a.dist === b.dist) ? 0 : 1));\n  //     });\n  //     for (let i = 0; i < list.length; i++) {\n  //       dirs[i] = list[i].dir;\n  //       moveDistances[i] = list[i].dist;\n  //       nextTiles[i] = list[i].tile;\n  //     }\n\n  //     let selectedDir;\n  //     for (let j = 0; j < dirs.length; j++) {\n  //       let nextTile = nextTiles[j];\n  //       if (tiles[nextTile[1]][nextTile[0]] === 1) {\n  //         selectedDir = dirs[j];\n  //         break;\n  //       }\n  //     }\n  //     this.dir = selectedDir;\n  //     if (this.name === \"blinky\") {\n  //       console.log(dirs, moveDistances, nextTiles, selectedDir);\n  //     }\n  //   }\n  //   this.moveOnce();\n  // }\n\n  calcDist(pos1, pos2) {\n    return Math.sqrt(Math.pow(pos1[0] - pos2[0], 2) + Math.pow(pos1[1] - pos2[1], 2));\n  }\n\n  inBounds(pos) {\n    return (\n      pos[0] >= 0 &&\n      pos[1] >= 0 &&\n      pos[0] <= (DEFAULTS.boardSize - DEFAULTS.gridSize) &&\n      pos[0] <= (DEFAULTS.boardSize - DEFAULTS.gridSize)\n    );\n  }\n  target(pos, walls) {\n    const xDif = this.pos[0] - pos[0];\n    const yDif = this.pos[1] - pos[1];\n    if (this.pos[0] % DEFAULTS.gridSize === 0 && this.pos[1] % DEFAULTS.gridSize === 0) {\n      if (Math.abs(xDif) >= Math.abs(yDif)) {\n        if (!this.tryXMove(xDif, walls, false)) this.tryYMove(yDif, walls, true);\n      }\n      if (Math.abs(yDif) > Math.abs(xDif)) {\n        if (!this.tryYMove(yDif, walls, false)) this.tryXMove(xDif, walls, true);\n      }\n    } else {\n      this.moveOnce();\n    }\n  }\n\n  tryXMove(xDif, walls, retry) {\n    if (xDif >= 0 && !this.willCollide([-1, 0], walls, !this.checkDirEquality([-1, 0], this.dir))) {\n      this.dir = [-1, 0];\n      this.moveOnce();\n      return true;\n    } else if (xDif < 0 && !this.willCollide([1, 0], walls, !this.checkDirEquality([1, 0], this.dir))) {\n      this.dir = [1, 0];\n      this.moveOnce();\n      return true;\n    } else {\n      if (retry) {\n        this.moveRandomly(walls);\n      } else {\n        return false;\n      }\n    }\n  }\n\n  tryYMove(yDif, walls, retry) {\n    if (yDif >= 0 && !this.willCollide([0, -1], walls, !this.checkDirEquality([0, -1], this.dir))) {\n      this.dir = [0, -1];\n      this.moveOnce();\n    } else if (yDif < 0 && !this.willCollide([0, 1], walls, !this.checkDirEquality([0, 1], this.dir))) {\n      this.dir = [0, 1];\n      this.moveOnce();\n    } else {\n      if (retry) {\n        this.moveRandomly(walls);\n      } else {\n        return false;\n      }\n    }\n  }\n\n  checkDirEquality(dir1, dir2) {\n    return (dir1[0] === dir2[0] && dir1[1] === dir2[1]);\n  }\n\n  moveOnce() {\n    this.pos = [this.pos[0] + this.dir[0] * this.vel, this.pos[1] + this.dir[1] * this.vel];\n  }\n\n  moveRandomly(walls) {\n    const dirs = [[-1, 0], [0, -1], [1, 0], [0, 1]];\n    const randomDir = dirs[Math.floor(Math.random() * 4)];\n    if (this.willCollide(randomDir, walls, !this.checkDirEquality(randomDir, this.dir))) {\n      this.moveRandomly(walls);\n    } else {\n      this.dir = randomDir;\n      this.moveOnce();\n    }\n  }\n\n  die(ctx) {\n    this.isFrightened = false;\n    this.isDead = true;\n    this.render(ctx);\n    this.pos = [this.startPos[0], this.startPos[1] + DEFAULTS.gridSize];\n    this.vel = 0;\n    setTimeout(() => {\n      this.pos = this.startPos;\n      this.vel = DEFAULTS.vel;\n      this.isDead = false;\n    }, 10000);\n  }\n}\n\nmodule.exports = Ghost;\n\n//# sourceURL=webpack:///./lib/ghost.js?");

        /***/
      }),

/***/ "./lib/moving_object.js":
/*!******************************!*\
  !*** ./lib/moving_object.js ***!
  \******************************/
/*! no static exports found */
/***/ (function (module, exports) {

        eval("const gridSize = 40;\nconst wallSize = 4;\nconst canvasSize = 805;\nclass MovingObject {\n  constructor({ pos, dir, vel, radius, color, board }) {\n    this.pos = pos;\n    this.dir = dir;\n    this.vel = vel;\n    this.radius = radius;\n    this.color = color;\n    this.board = board;\n    this.queuedDir = undefined;\n    this.willCollide = this.willCollide.bind(this);\n  }\n\n  willCollide(dir, walls, turning) {\n    const pos = this.pos;\n    const leftWalls = walls[\"LEFT\"];\n    const topWalls = walls[\"TOP\"];\n    const rightWalls = walls[\"RIGHT\"];\n    const bottomWalls = walls[\"BOTTOM\"];\n    const notCentered = (this.pos[0] % gridSize !== 0 || this.pos[1] % gridSize !== 0);\n    const aboveGhostHome = (this.pos[0] >= gridSize * 7 && this.pos[0] <= gridSize * 8 && this.pos[1] >= gridSize * 6 && this.pos[1] <= gridSize * 7);\n    if (!turning) {\n      if (dir[0] === -1 && dir[1] === 0) {\n        return this.includesArr(leftWalls, pos) || this.includesArr(rightWalls, [this.pos[0] - gridSize, this.pos[1]]);\n      } else if (dir[0] === 0 && dir[1] === -1) {\n        return this.includesArr(topWalls, pos) || this.includesArr(bottomWalls, [this.pos[0], this.pos[1] - gridSize]);\n      } else if (dir[0] === 1 && dir[1] === 0) {\n        return this.includesArr(rightWalls, pos) || this.includesArr(leftWalls, [this.pos[0] + gridSize, this.pos[1]]);\n      } else if (dir[0] === 0 && dir[1] === 1) {\n        return aboveGhostHome || this.includesArr(bottomWalls, pos) || this.includesArr(topWalls, [this.pos[0], this.pos[1] + gridSize]);\n      }\n    } else {\n      if (dir[0] === -1 && dir[1] === 0) {\n        return (\n          (notCentered && this.includesArr(bottomWalls, [Math.floor((this.pos[0] - gridSize) / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize])) ||\n          (notCentered && this.includesArr(topWalls, [Math.floor((this.pos[0] - gridSize) / gridSize) * gridSize, Math.floor((this.pos[1] + gridSize) / gridSize) * gridSize])) ||\n          this.includesArr(leftWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(leftWalls, [Math.ceil(this.pos[0] / gridSize) * gridSize, Math.ceil(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(rightWalls, [Math.floor((this.pos[0] - gridSize) / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(rightWalls, [Math.ceil((this.pos[0] - gridSize) / gridSize) * gridSize, Math.ceil(this.pos[1] / gridSize) * gridSize])\n        );\n      } else if (dir[0] === 0 && dir[1] === -1) {\n        return (\n          (notCentered && this.includesArr(rightWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor((this.pos[1] - gridSize) / gridSize) * gridSize])) ||\n          (notCentered && this.includesArr(leftWalls, [Math.floor((this.pos[0] + gridSize) / gridSize) * gridSize, Math.floor((this.pos[1] - gridSize) / gridSize) * gridSize])) ||\n          this.includesArr(topWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(topWalls, [Math.ceil(this.pos[0] / gridSize) * gridSize, Math.ceil(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(bottomWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor((this.pos[1] - gridSize) / gridSize) * gridSize]) ||\n          this.includesArr(bottomWalls, [Math.ceil(this.pos[0] / gridSize) * gridSize, Math.ceil((this.pos[1] - gridSize) / gridSize) * gridSize])\n        );\n      } else if (dir[0] === 1 && dir[1] === 0) {\n        return (\n          (notCentered && this.includesArr(bottomWalls, [Math.floor((this.pos[0] + gridSize) / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize])) ||\n          (notCentered && this.includesArr(topWalls, [Math.floor((this.pos[0] + gridSize) / gridSize) * gridSize, Math.floor((this.pos[1] + gridSize) / gridSize) * gridSize])) ||\n          this.includesArr(rightWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(rightWalls, [Math.ceil(this.pos[0] / gridSize) * gridSize, Math.ceil(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(leftWalls, [Math.floor((this.pos[0] + gridSize) / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(leftWalls, [Math.ceil((this.pos[0] + gridSize) / gridSize) * gridSize, Math.ceil(this.pos[1] / gridSize) * gridSize])\n        );\n      } else if (dir[0] === 0 && dir[1] === 1) {\n        return (\n          aboveGhostHome ||\n          (notCentered && this.includesArr(rightWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor((this.pos[1] + gridSize) / gridSize) * gridSize])) ||\n          (notCentered && this.includesArr(leftWalls, [Math.floor((this.pos[0] + gridSize) / gridSize) * gridSize, Math.floor((this.pos[1] + gridSize) / gridSize) * gridSize])) ||\n          this.includesArr(bottomWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(bottomWalls, [Math.ceil(this.pos[0] / gridSize) * gridSize, Math.ceil(this.pos[1] / gridSize) * gridSize]) ||\n          this.includesArr(topWalls, [Math.floor(this.pos[0] / gridSize) * gridSize, Math.floor((this.pos[1] + gridSize) / gridSize) * gridSize]) ||\n          this.includesArr(topWalls, [Math.ceil(this.pos[0] / gridSize) * gridSize, Math.ceil((this.pos[1] + gridSize) / gridSize) * gridSize])\n        );\n      }\n    }\n  }\n\n  includesArr(mainArr, subArr) {\n    for (let i = 0; i < mainArr.length; i++) {\n      if (JSON.stringify(mainArr[i]) === JSON.stringify(subArr)) return true;\n    }\n    return false;\n  }\n\n  move(walls) {\n    if (this.queuedDir && !this.willCollide(this.queuedDir, walls, true)) {\n      this.dir = this.queuedDir;\n      this.queuedDir = undefined;\n    }\n    if (!this.willCollide(this.dir, walls, false)) {\n      this.pos = [this.pos[0] + this.dir[0] * this.vel, this.pos[1] + this.dir[1] * this.vel];\n    }\n    this.wrap();\n  }\n\n  turn(dir, walls) {\n    if (!this.willCollide(dir, walls, true)) {\n      this.dir = dir;\n      this.queuedDir = undefined;\n    } else {\n      this.queuedDir = dir;\n    }\n  }\n\n  // goes out of bounds to transition more smoothly\n  wrap() {\n    if (this.pos[0] < 0 && (this.dir[0] === -1 && this.dir[1] === 0)) {\n      this.pos = [canvasSize, this.pos[1]];\n    } else if (this.pos[0] > canvasSize && (this.dir[0] === 1 && this.dir[1] === 0)) {\n      this.pos = [-gridSize / 2, this.pos[1]];\n    }\n  }\n}\n\nmodule.exports = MovingObject;\n\n//# sourceURL=webpack:///./lib/moving_object.js?");

        /***/
      })

    /******/
  });